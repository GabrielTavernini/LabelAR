using System;
using System.Collections;
using System.Collections.Generic;
using MagicLeap.OpenXR.Features.LocalizationMaps;
using MagicLeap.OpenXR.Features.SpatialAnchors;
using MagicLeap.OpenXR.Subsystems;
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.XR.ARFoundation;
using UnityEngine.XR.ARSubsystems;
using UnityEngine.XR.Management;
using UnityEngine.XR.OpenXR;
using UnityEngine.XR.OpenXR.NativeTypes;
using static UnityEngine.InputSystem.InputAction;

public class Adjustment : MonoBehaviour
{
    [SerializeField] private ARAnchorManager anchorManager;
 
    // This is was autogenerated and allows developers to create a dynamic
    // instance of an InputActionAsset which includes predefined action maps
    // that correspond to all of the Magic Leap 2's input.
    private MagicLeapInput _magicLeapInputs;
    
    // This class is an Action Map and was autogenerated by the Unity Input
    // System and includes predefined bindings for the Magic Leap 2 Controller
    // Input Events.
    private MagicLeapInput.ControllerActions _controllerActions;

    private bool triggerPressed = false;
    private float prevRotation = 0;
    private bool adjustmentMode = false;

    // Anchor stuff
    private MagicLeapSpatialAnchorsStorageFeature anchorStorageFeature;
    private MagicLeapLocalizationMapFeature mapFeature;
    private MLXrAnchorSubsystem activeSubsystem;
    private List<ARAnchor> activeAnchors = new();   
    private readonly List<ARAnchor> activeAnchorsStored = new();

    private void Start() {

    }

    public IEnumerator StartSpatialAnchors()
    {
        // Initialize the InputActionAsset
        _magicLeapInputs = new MagicLeapInput();
        _magicLeapInputs.Enable();

        //Initialize the ControllerActions using the Magic Leap Input
        _controllerActions = new MagicLeapInput.ControllerActions(_magicLeapInputs);

        //Subscribe to your choice of the controller events
        ToggleAdjustmentMode();
        _controllerActions.MenuButton.performed += OnMenuClick;
        _controllerActions.Bumper.started += OnBumperClick;
        _controllerActions.Bumper.canceled += OnBumperRelease;

        // Waits until AR subsystems are loaded before proceeding.
        yield return new WaitUntil(AreSubsystemsLoaded);
        anchorStorageFeature = OpenXRSettings.Instance.GetFeature<MagicLeapSpatialAnchorsStorageFeature>();
        mapFeature = OpenXRSettings.Instance.GetFeature<MagicLeapLocalizationMapFeature>();
        mapFeature.EnableLocalizationEvents(true);

        anchorStorageFeature.OnCreationCompleteFromStorage += OnAnchorCompletedCreationFromStorage;
        anchorStorageFeature.OnPublishComplete += OnAnchorPublishComplete;
        anchorStorageFeature.OnQueryComplete += OnAnchorQueryComplete;
        anchorStorageFeature.OnDeletedComplete += OnAnchorDeleteComplete;
        anchorManager.anchorsChanged += OnAnchorsChanged;

        ReadAnchors();
    }
    
    private bool AreSubsystemsLoaded()
    {
        if (XRGeneralSettings.Instance == null || XRGeneralSettings.Instance.Manager == null ||
            XRGeneralSettings.Instance.Manager.activeLoader == null) return false;
        activeSubsystem =
            XRGeneralSettings.Instance.Manager.activeLoader.GetLoadedSubsystem<XRAnchorSubsystem>() as
                MLXrAnchorSubsystem;
        return activeSubsystem != null;
    }
    
    void Update()
    {
        if(triggerPressed && _controllerActions.IsTracked.IsPressed()
            && !MarkerUnderstanding.firstDetection && adjustmentMode) {
            float current = _controllerActions.PointerRotation.ReadValue<Quaternion>().eulerAngles.y;
            float angleDelta = Mathf.DeltaAngle(prevRotation, current) / 5;
            Debug.Log("Rotating:" + angleDelta);
            MarkerUnderstanding.aprilTag.transform.Rotate(new Vector3(0,angleDelta,0));
            prevRotation = current;
        }
    }

    private void ToggleAdjustmentMode() {
        adjustmentMode = !adjustmentMode;
        Debug.Log("Toggled adjustment mode to " + adjustmentMode);
        
        WorldLoader.ChangeShader(!adjustmentMode);
        if(adjustmentMode)
            MarkerUnderstanding.UnfreezeAprilCode();
        else
            MarkerUnderstanding.FreezeAprilCode();
    }

    private void OnMenuClick(CallbackContext obj)
    {   
        ToggleAdjustmentMode();

        if(!adjustmentMode) {
            Pose currentPose = new Pose(MarkerUnderstanding.aprilTag.transform.position, MarkerUnderstanding.aprilTag.transform.rotation);
            Debug.Log("SpatialAnchorsTest: Menu hit, creating Anchor at " + currentPose);

            // Instantiating a new anchor at the current pose and adding it to the list of active anchors.
            GameObject newAnchor = Instantiate(anchorManager.anchorPrefab, currentPose.position, currentPose.rotation);
            ARAnchor newAnchorComponent = newAnchor.AddComponent<ARAnchor>();
            activeAnchors.Add(newAnchorComponent);
            StartCoroutine(CreateAnchor(newAnchorComponent));
        }
    }

    private IEnumerator CreateAnchor(ARAnchor toPublish)
    {
        while (toPublish.trackingState != TrackingState.Tracking)
            yield return null;

        Debug.Log(
            "Anchors count: " + activeAnchors.Count + "\n" +
            "Anchors Storage count: " + activeAnchorsStored.Count + "\n"
        );
        if (activeAnchorsStored.Count > 0) {
            anchorStorageFeature.DeleteStoredSpatialAnchors(activeAnchorsStored);
        }
        anchorStorageFeature.PublishSpatialAnchorsToStorage(new List<ARAnchor> {toPublish}, 0);            
    }

    private void ReadAnchors()
    {
        anchorStorageFeature.QueryStoredSpatialAnchors(new Vector3(), 10);
    }

    #region persistence callbacks
    // All the anchor storage features are asynchronous and have callbacks for when the call is complete
    private void OnAnchorPublishComplete(ulong anchorId, string anchorMapPositionId)
    {
        Pose newAnchorPose = activeSubsystem.GetAnchorPoseFromId(anchorId);

        Debug.Log($"SpatialAnchorsStorageTest: Anchor Publish Complete hit for location: {newAnchorPose.ToString()}");
    }

    // This is where all persisted anchors found during a query will be returned.
    private void OnAnchorQueryComplete(List<string> anchorMapPositionIds)
    {
        // Find Anchors already known to Subsystem
        List<string> alreadyCreated = new List<string>();

        foreach (var storedAnchor in activeAnchorsStored)
        {
            string anchorMapPositionId = activeSubsystem.GetAnchorMapPositionId(storedAnchor);
            if (anchorMapPositionIds.Contains(anchorMapPositionId))
            {
                alreadyCreated.Add(anchorMapPositionId);
            }
        }

        // Create New Anchors
        List<string> createStoredAnchors = new List<string>();

        foreach (string storedAnchor in anchorMapPositionIds)
        {
            TrackableId subsystemId = activeSubsystem.GetTrackableIdFromMapPositionId(storedAnchor);
            ARAnchor foundAnchor = anchorManager.GetAnchor(subsystemId);
            if (!alreadyCreated.Contains(storedAnchor) && foundAnchor == null)
            {
                createStoredAnchors.Add(storedAnchor);
            }
        }

        if (createStoredAnchors.Count > 0)
        {
            bool result = anchorStorageFeature.CreateSpatialAnchorsFromStorage(createStoredAnchors);

            if (!result)
            {
                Debug.LogError("SpatialAnchorsStorageTest: Error creating Anchors from storage Id.");
            }
        }
    }

    // This is where anchors found by a query, that were not already in the scene, and were subsequently created from 
    // storage are instantiated into the unity scene.
    private void OnAnchorCompletedCreationFromStorage(Pose pose, ulong anchorId, string anchorMapPositionId,
        XrResult result)
    {
        ToggleAdjustmentMode();
        MarkerUnderstanding.Stop();
        MarkerUnderstanding.SetAprilCode(0, pose.position, pose.rotation);
        Debug.Log($"SpatialAnchorsStorageTest: Anchor Creation from Storage Complete hit for location: {pose.ToString()} With result: {result.ToString()}");
    }

    // This is where a confirmation of deletion will happen and the current scene representation of the anchor
    // can be removed
    private void OnAnchorDeleteComplete(List<string> anchorMapPositionIds)
    {
        Debug.Log($"SpatialAnchorsStorageTest: Anchor Delete Complete hit with {anchorMapPositionIds.Count} results.");
    }

    private void OnAnchorsChanged(ARAnchorsChangedEventArgs anchorsChanged)
    {
        Debug.Log("OnAnchorsChanged: \n" +
            "Anchors Added count: " + anchorsChanged.added.Count + "\n" +
            "Anchors Removed count: " + anchorsChanged.removed.Count + "\n"
        );
        // Check for newly added Stored Anchors this Script may not yet know about.
        foreach (ARAnchor anchor in anchorsChanged.added)
        {
            if (activeSubsystem.IsStoredAnchor(anchor))
            {
                activeAnchorsStored.Add(anchor);
            }
        }

        foreach (ARAnchor anchor in anchorsChanged.updated)
        {
            if (activeSubsystem.IsStoredAnchor(anchor) && !activeAnchorsStored.Contains(anchor))
            {
                activeAnchorsStored.Add(anchor);
            }
        }
        
        // Check if we are still tracking a deleted anchor.
        foreach (ARAnchor anchor in anchorsChanged.removed)
        {
            if (activeAnchorsStored.Contains(anchor))
            {
                activeAnchorsStored.Remove(anchor);
            }
        }
    }
    #endregion

    private void OnBumperClick(InputAction.CallbackContext obj)
    {   
        if(adjustmentMode) {
            prevRotation = _controllerActions.PointerRotation.ReadValue<Quaternion>().eulerAngles.y;
            triggerPressed = true;
        }
    }

    private void OnBumperRelease(InputAction.CallbackContext obj)
    {   
        triggerPressed = false;
    }

    // Handles the disposing all of the input events.
    void OnDestroy()
    {
        _controllerActions.Trigger.started -= OnBumperClick;
        _controllerActions.Trigger.canceled -= OnBumperRelease;
        _controllerActions.MenuButton.performed -= OnMenuClick;
        
        anchorStorageFeature.OnCreationCompleteFromStorage -= OnAnchorCompletedCreationFromStorage;
        anchorStorageFeature.OnPublishComplete -= OnAnchorPublishComplete;
        anchorStorageFeature.OnQueryComplete -= OnAnchorQueryComplete;
        anchorStorageFeature.OnDeletedComplete -= OnAnchorDeleteComplete;
        anchorManager.anchorsChanged -= OnAnchorsChanged;

        _magicLeapInputs.Dispose();
    }
}